## What is Zookeeper

Zookeeper is a centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services. 
All of these kinds of services are used in some form or another by distributed applications. Each time they are implemented there is a lot of work that goes into fixing the bugs and race conditions that are inevitable. Because of the difficulty of implementing these kinds of services, applications initially usually skimp on them, which make them brittle in the presence of change and difficult to manage. Even when done correctly, different implementations of these services lead to management complexity when the applications are deployed. 

Zookeeper aims to distill the essence of these different services into a very simple interface to a centralized coordination service. The service itself is distributed and highly reliable. Consensus, group management, and presence protocols will be implemented by the service so that the applications do not need to implement them on their own. Application specific uses of these will consist of a mixture of specific components of Zookeeper and application specific conventions. 

## Overview
Zookeeper allows distributed processes to coordinate with each other through a shared hierarchical namespace of data registers (aka znodes), much like a file system. 

The name space provided by Zookeeper is much like that of a standard file system. A name is a sequence of path elements separated by a "/". Every znode in Zookeepers name space is identified by a path. And every znode has a parent whose path is a prefix of the znode with one less element; the exception to this rule is root ("/") which has no parent. Also, exactly like a standard file system, a znode cannot be deleted if it has any children. 

The main differences between Zookeeper and standard file systems is that every znode can have data associated with it (every file can also be a directory and vice-versa) and znodes are limited to the amount of data that they can have. Zookeeper was designed to store coordination data: status information, configuration, location information, etc. This kind of meta-information is usually measured in kilobytes, it not bytes. Zookeeper has a built-in sanity check of 1M, to prevent it from being used as a large data store, but in general it is used to store much smaller pieces of data. 

The service itself is replicated over a set of machines that comprise the service. These machines maintain an in-memory image of the data tree along with a transaction log and snapshots in a persistent store. Because the data is kept in-memory, Zookeeper is able to get very high throughput and low latency numbers. The downside is that the size of the database that Zookeeper can manage is limited by memory. This limitation is further reason to keep the amount of data stored in znodes small. 

The servers that make up the Zookeeper service must all know about each other. As long as a majority of the services are available, the Zookeeper service will be available. Clients must also know the list of servers. The clients create a handle to the Zookeeper service using this list of servers. 

Clients only connect to a single Zookeeper server. The client maintains a TCP connection through which it sends requests, gets responses, gets watch events, and sends heartbeats. If the TCP connection to the server breaks, the client will connect to a different server. When a client first connects to the Zookeep service, the first Zookeeper server will setup a session for the client. If the client needs to connect to another server, this session will get reestablished with the new server. 

Read requests sent by a Zookeeper client are processed locally at the Zookeeper server to which the client is connected. If the read request registeres a watch on a znode, that watch is also tracked locally at the Zookeeper server. Write requests are forwarded to other Zookeeper servers and go through the consensus before a response is generated. Sync requests Sync requests are also forwarded to another server, but do not actually go through consensus. Thus, the throughput of read requests scales with the number of servers and the throughput of write requests decreases with the number of servers. 

Order is very important to Zookeeper; almost bordering on obsessive-compulsive disorder. All updates are totally ordered. Zookeeper actually stamps each update with a number that reflects this order. We call this number the zxid (Zookeeper transaction id). Each update will have a unique zxid. Reads (and watches) are ordered with respect to updates. 