
The goal of this post is to dive a bit deeper into the "Hosted Service" model provided by ASP.NET Core. While you could use the Hosted Service model since ASP.NET Core 2.1, the release of .NET Core 3 provided us with a new "Worker Service" Visual Studio template that  outlines how simple and easy it is to create a long-running service that can do pretty much anything and be deployed pretty much anywhere using .NET Core. 

*NOTE: While the new "Worker Service" template provides an environment for a single Hosted Service to run, you can also add one or more Hosted Services to any ASP.NET Core application using the `AddHostedService<T>` API in the `ConfigureServices` method of your `HostBuilder` (as shown later in this tutorial).*

Let's start by creating our first service, which we will just call "TimerService". We will do this by creating a new Project in Visual Studio and selecting the "Worker Service" template in Visual Studio. Let's name the project "TimerService" and the solution "SampleServices". 

After the solution is created we see our TimerService project and some starter code. Let's check out the `Program.cs` file that was generated:

```csharp
// => Program.cs

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace TimerService 
{
    public class Program
    {
        public static void Main(string[] args) 
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) => 
            Host.CreateDefaultBuilder(args)
                .ConfigureServices((hostContext, services) => 
                {
                    services.AddHostedService<Worker>();
                })
    }
}
```

So as we can see here, the generated service is just a console application. If you are familiar with ASP.NET Core, then this probably looks very familiar to you. The difference between this and your typical ASP.NET Core app is that the static `Host` used in the `CreateHostBuilder` method is using the `CreateDefaultBuilder` method, which initializes a new instance of a HostBuilder class with pre-configured defaults, such as reading environment variables prefixed with `DOTNET_` into the host configuration and configuring a default logger, to name a few. A typical ASP.NET Core project will additionally call the `ConfigureWebHostDefaults` method, which adds additional defaults that make sense for web applications. 

The exciting thing to me here is that we can use *almost* the same template for all kinds of different applications/services. 

If we look at the lambda expression provided to the `ConfigureServices` method (which also looks very familiar to a typical `Startup.cs` file that we'd see in an ASP.NET Core web application), we see that we are using a generic `AddHostedService<T>` method that is using the `Worker` type as the generic type parameter. 

This `Worker` class is contained in another file that was generated by the template, aptly named `Worker.cs`:
```csharp
// => Worker.cs

// using statements and namespace ommited for brevity

public class Worker : BackgroundService
{
    private readonly ILogger<Worker> _logger;

    public Worker(ILogger<Worker> logger)
    {
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken) 
    {
        while(!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation("Worker running at: {time}", DateTimeOffset.Now);
            await Task.Delay(1000, stoppingToken);
        }
    }
}
```
So this looks kind of simple, right? We get a logger provided to us by the built-in dependency injection system and we override an `ExecuteAsync` method that comes from `BackgroundService` that our `Worker` class inherits from. Inside our `ExecuteAsync` method is where all the work happens, and for now we are just output the time every second. Also of note is that surrounding the code is a while loop that is checking that our CancellationToken that was passed in as a parameter hasn't requested cancellation. 

Let's now take a deeper look into that `BackgroundService` class that we are inheriting from. We can actually view the full source [here](https://source.dot.net/#Microsoft.Extensions.Hosting.Abstractions/BackgroundService.cs) but for now let's just look at the definition provided in Visual Studio. 
```csharp
public abstract class BackgroundService : IHostedService, IDisposable
{
    protected BackgroundService();

    public virtual void Dispose();

    public virtual Task StartAsync(CancellationToken cancellationToken);
    public virtual Task StopAsync(CancellationToken cancellationToken);
    public virtual Task ExecuteAsync(CancellationToken stoppingToken);
}
```

We can see here that BackgroundService implements IHostedService, and there are three methods that are of interest:
- `StartAsync` - Triggered when the application host is ready to start the service.
- `StopAsync` - Triggered when the application host is performing a graceful shutdown.
- `ExecuteAsync` - Called when the Microsoft.Extensions.Hosting.IHostedService starts. The implementation should return a task that represents the lifetime of the long-running operations being performed. 

These methods provide us with a sort of lifecycle for our service. In addition to the `ExecuteAsync` method, we can also override the `StartAsync` and `StopAsync` methods to modify what happens when our service, well, starts and stops. 





