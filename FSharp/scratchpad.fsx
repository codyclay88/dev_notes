
let emptyList: int list = []  
let anotherEmpty = List<int>.Empty
let basic = [1;2;3;4;5]
let overMultipleLines = [
    1
    2
    3 
]
let withRange = [1..5]
let withRangeExtra = [1..2..10] 
let withListExpression = [for i in 1..5 -> i]
let withConsOperator = 1 :: [2;3;4;5]
let chainingCons = 1 :: 2 :: [3;4;5] 
let extremeChaining = 1 :: 2 :: 3 :: 4 :: 5 :: []
let staticCons = List.Cons(1, [2;3;4;5])

List.allPairs [1;2] [1;2]
//=> val it : (int * int) list = [(1, 1); (1, 2); (2, 1); (2, 2)]
// Summary: 
// Possible use case: Quickly drawing out a tilemap for a game map 

List.append [1;2] [3;4]
//=> val it : int list = [1; 2; 3; 4]
// Summary: Returns a new list that contains the elements of the first list followed by the elements of the second

open System

List.average [1.;2.;3.;4.;5.]
//=> val it : float = 3.0
// Returns the average of a list of elements

List.averageBy (fun i -> float(i)) [1;2;3;4;5]
//=> val it : float = 3.0
// Returns the average of the elements generated by applying the function to each element of the list

// Need better example here
let chooseHelper value = Some (float(value))
List.choose chooseHelper [1;2;3;4;5]

let aList = [for i in 1..100 do if i % 2 = 0 then yield i]
let aSeq  = seq {for i in 1..100 do if i % 2 = 0 then yield i}

// Mapping functions - 
// these functions take a collection of items and return another collection of items. 

type PersonInfo = {
    Name: string
    Town: string
} with 
    static member Create name town = { Name = name; Town = town }

let personList = [
    PersonInfo.Create "Issac" "London"
    PersonInfo.Create "Sara" "Birmingham"
    PersonInfo.Create "Tim" "London"
    PersonInfo.Create "Michelle" "Manchester"
]

// List.map -> converts all the items in a collection from one shape into another shape
List.map (fun p -> p.Town) personList 
// vv How map is implemented
// let inline setFreshConsTail cons t = cons.(::).1 <- t
// let inline freshConsNoTail h = h :: (# "ldnull" : 'T list #)
// let rec mapToFreshConsTail cons f x = 
//      match x with
//      | [] -> 
//           setFreshConsTail cons []
//      | h::t -> 
//          let cons2 = freshConsNoTail (f h)
//          setFreshConsTail cons cons2
//          mapToFreshConsTail cons2 f t
// let map mapping x = 
//         match x with
//         | [] -> []
//         | [h] -> [mapping h]
//         | h::t -> 
//             let cons = freshConsNoTail (mapping h)
//             mapToFreshConsTail cons mapping t
//             cons

List.mapi (fun i p -> p.Name) personList

// List.iter -> like map but must return unit
List.iter (fun p -> printfn "Hello %s from %s" p.Name p.Town) personList

